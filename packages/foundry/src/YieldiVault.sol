// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title YieldiVault
 * @dev Simplified ERC-4626 inspired vault that accepts ETH deposits and generates yield
 * @notice This vault allows users to deposit ETH and receive shares representing their portion of the vault
 */
contract YieldiVault {
    // ERC20 functionality
    string public name = "Yieldi Vault Shares";
    string public symbol = "YVSSSS";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    // Ownership
    address public owner;
    
    // ReentrancyGuard
    uint256 private _status = 1;
    
    /// @dev Mock lending protocol yield rate (basis points, e.g., 500 = 5%)
    uint256 public constant ANNUAL_YIELD_RATE = 500; // 5% APY
    
    /// @dev Last time yield was accrued
    uint256 public lastYieldAccrual;
    
    /// @dev Total yield generated by the vault
    uint256 public totalYieldGenerated;
    
    /// @dev Minimum deposit amount (0.001 ETH)
    uint256 public constant MIN_DEPOSIT = 0.001 ether;
    
    /// @dev Events
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);
    event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);
    event YieldAccrued(uint256 amount, uint256 timestamp);
    event EmergencyWithdraw(address indexed owner, uint256 amount);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    /// @dev Modifiers
    modifier onlyOwner() {
        require(msg.sender == owner, "YieldiVault: caller is not the owner");
        _;
    }
    
    modifier nonReentrant() {
        require(_status == 1, "YieldiVault: reentrant call");
        _status = 2;
        _;
        _status = 1;
    }
    
    /**
     * @dev Constructor initializes the vault
     */
    constructor() {
        owner = msg.sender;
        lastYieldAccrual = block.timestamp;
        emit OwnershipTransferred(address(0), msg.sender);
    }
    
    /**
     * @dev ERC20 transfer function
     */
    function transfer(address to, uint256 amount) external returns (bool) {
        require(to != address(0), "YieldiVault: transfer to zero address");
        require(balanceOf[msg.sender] >= amount, "YieldiVault: transfer amount exceeds balance");
        
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    /**
     * @dev ERC20 transferFrom function
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(to != address(0), "YieldiVault: transfer to zero address");
        require(balanceOf[from] >= amount, "YieldiVault: transfer amount exceeds balance");
        require(allowance[from][msg.sender] >= amount, "YieldiVault: transfer amount exceeds allowance");
        
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        allowance[from][msg.sender] -= amount;
        
        emit Transfer(from, to, amount);
        return true;
    }
    
    /**
     * @dev ERC20 approve function
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    /**
     * @dev Internal mint function
     */
    function _mint(address to, uint256 amount) internal {
        require(to != address(0), "YieldiVault: mint to zero address");
        
        totalSupply += amount;
        balanceOf[to] += amount;
        
        emit Transfer(address(0), to, amount);
    }
    
    /**
     * @dev Internal burn function
     */
    function _burn(address from, uint256 amount) internal {
        require(from != address(0), "YieldiVault: burn from zero address");
        require(balanceOf[from] >= amount, "YieldiVault: burn amount exceeds balance");
        
        balanceOf[from] -= amount;
        totalSupply -= amount;
        
        emit Transfer(from, address(0), amount);
    }
    
    /**
     * @dev Get total assets under management (ETH balance + accrued yield)
     */
    function totalAssets() public view returns (uint256) {
        return address(this).balance + _calculatePendingYield();
    }
    
    /**
     * @dev Preview deposit - calculate shares for given assets
     */
    function previewDeposit(uint256 assets) public view returns (uint256) {
        return _convertToShares(assets);
    }
    
    /**
     * @dev Preview redeem - calculate assets for given shares
     */
    function previewRedeem(uint256 shares) public view returns (uint256) {
        return _convertToAssets(shares);
    }
    
    /**
     * @dev Convert assets to shares
     */
    function _convertToShares(uint256 assets) internal view returns (uint256) {
        uint256 supply = totalSupply;
        return supply == 0 ? assets : (assets * supply) / totalAssets();
    }
    
    /**
     * @dev Convert shares to assets
     */
    function _convertToAssets(uint256 shares) internal view returns (uint256) {
        uint256 supply = totalSupply;
        return supply == 0 ? shares : (shares * totalAssets()) / supply;
    }
    
    /**
     * @dev Deposit ETH and mint vault shares
     * @param receiver Address to receive the vault shares
     * @return shares Amount of shares minted
     */
    function depositETH(address receiver) external payable nonReentrant returns (uint256 shares) {
        require(msg.value >= MIN_DEPOSIT, "YieldiVault: Deposit below minimum");
        require(receiver != address(0), "YieldiVault: Invalid receiver");
        
        _accrueYield();
        
        uint256 assets = msg.value;
        shares = previewDeposit(assets);
        
        _mint(receiver, shares);
        
        emit Deposit(msg.sender, receiver, assets, shares);
    }
    
    /**
     * @dev Withdraw ETH by burning vault shares
     * @param shares Amount of shares to burn
     * @param receiver Address to receive ETH
     * @param shareOwner Address that owns the shares
     * @return assets Amount of ETH withdrawn
     */
    function redeemETH(
        uint256 shares,
        address payable receiver,
        address shareOwner
    ) external nonReentrant returns (uint256 assets) {
        require(receiver != address(0), "YieldiVault: Invalid receiver");
        require(shares > 0, "YieldiVault: Invalid shares amount");
        
        if (msg.sender != shareOwner) {
            require(allowance[shareOwner][msg.sender] >= shares, "YieldiVault: insufficient allowance");
            allowance[shareOwner][msg.sender] -= shares;
        }
        
        _accrueYield();
        
        assets = previewRedeem(shares);
        require(assets <= address(this).balance, "YieldiVault: Insufficient liquidity");
        
        _burn(shareOwner, shares);
        
        (bool success, ) = receiver.call{value: assets}("");
        require(success, "YieldiVault: ETH transfer failed");
        
        emit Withdraw(msg.sender, receiver, shareOwner, assets, shares);
    }
    
    /**
     * @dev Calculate current APY based on yield rate
     * @return apy Current annual percentage yield in basis points
     */
    function getCurrentAPY() external pure returns (uint256 apy) {
        return ANNUAL_YIELD_RATE;
    }
    
    /**
     * @dev Get user's balance in ETH equivalent
     * @param account User address
     * @return ethBalance ETH value of user's shares
     */
    function getUserETHBalance(address account) external view returns (uint256 ethBalance) {
        uint256 userShares = balanceOf[account];
        if (userShares == 0) return 0;
        return previewRedeem(userShares);
    }
    
    /**
     * @dev Accrue yield based on time elapsed and yield rate
     */
    function _accrueYield() internal {
        uint256 timeElapsed = block.timestamp - lastYieldAccrual;
        if (timeElapsed == 0 || address(this).balance == 0) return;
        
        uint256 yield = _calculatePendingYield();
        if (yield > 0) {
            totalYieldGenerated += yield;
            lastYieldAccrual = block.timestamp;
            emit YieldAccrued(yield, block.timestamp);
        }
    }
    
    /**
     * @dev Calculate pending yield based on time elapsed
     */
    function _calculatePendingYield() internal view returns (uint256) {
        uint256 timeElapsed = block.timestamp - lastYieldAccrual;
        if (timeElapsed == 0 || address(this).balance == 0) return 0;
        
        // Simple linear yield calculation: (principal * rate * time) / (365 days * 10000)
        uint256 annualizedYield = (address(this).balance * ANNUAL_YIELD_RATE * timeElapsed) / (365 days * 10000);
        return annualizedYield;
    }
    
    /**
     * @dev Emergency withdraw function for owner (in case of critical issues)
     * @param amount Amount of ETH to withdraw
     */
    function emergencyWithdraw(uint256 amount) external onlyOwner {
        require(amount <= address(this).balance, "YieldiVault: Insufficient balance");
        
        (bool success, ) = payable(owner).call{value: amount}("");
        require(success, "YieldiVault: Emergency withdraw failed");
        
        emit EmergencyWithdraw(owner, amount);
    }
    
    /**
     * @dev Transfer ownership
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "YieldiVault: new owner is the zero address");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
    
    /**
     * @dev Renounce ownership
     */
    function renounceOwnership() external onlyOwner {
        emit OwnershipTransferred(owner, address(0));
        owner = address(0);
    }
    
    /**
     * @dev Allow contract to receive ETH
     */
    receive() external payable {
        // Allow direct ETH deposits for yield simulation
        if (msg.sender != address(this)) {
            // This would be yield from lending protocols
            totalYieldGenerated += msg.value;
        }
    }
}